
/**
 * The Hack CPU (Central Processing unit), consisting of an ALU, two
 * registers named A and D, and a program counter named PC.  The CPU
 * is designed to fetch and execute instructions written in the Hack
 * machine language. In particular, functions as follows: Executes the
 * inputted instruction according to the Hack machine language
 * specification. The D and A in the language specification refer to
 * CPU-resident registers, while M refers to the external memory
 * location addressed by A, i.e. to Memory[A]. The inM input holds the
 * value of this location. If the current instruction needs to write a
 * value to M, the value is placed in outM, the address of the target
 * location is placed in the addressM output, and the writeM control
 * bit is asserted. (When writeM==0, any value may appear in
 * outM). The outM and writeM outputs are combinational: they are
 * affected instantaneously by the execution of the current
 * instruction. The addressM and pc outputs are clocked: although they
 * are affected by the execution of the current instruction, they
 * commit to their new values only in the next time step. If reset==1
 * then the CPU jumps to address 0 (i.e. pc is set to 0 in next time
 * step) rather than to the address resulting from executing the
 * current instruction.
 */

CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
     instruction[16],    // Instruction for execution
     reset;              // Signals whether to re-start the current
    // program (reset==1) or continue executing
    // the current program (reset==0).

    OUT outM[16],        // M value output
     writeM,             // Write to M?
     addressM[15],       // Address in data memory (of M)
     pc[15];             // address of next instruction

PARTS:
    /* instruction[15] = i     instruction[11] = zx     instruction[5]  = destA
                               instruction[10] = nx     instruction[4]  = destD
       instruction[12] = a     instruction[9]  = zy     instruction[3]  = destM
                               instruction[8]  = ny
                               instruction[7]  = f      instruction[2]  = j2
                               instruction[6]  = no;    instruction[1]  = j1
                                                        instruction[0]  = j0) */

    /* A-instruction vs. C-instruction */
    Not(in = instruction[15], out = aInstruction);

    /* Write to Memory? */

    And(a = instruction[15], b = instruction[3], out = writeM);
    
    /* D */
    And(a = instruction[4], b = instruction[15], out = writeD);
    Register(in = aluValue, load = writeD, out = dReg);
    
    /* A */
    Or(a = aInstruction, b = instruction[5], out = writeA);
    Register(in = inA, load = writeA, out[0..14] = aReg, out[0..14] = addressM);

    /* value of A */
    Mux16(a[0..14] = instruction[0..14], a[15] = false,
          b = aluValue,
          sel = instruction[15],
          out = inA);

    /* select A or M input for ALU */
    Mux16(a[0..14] = aReg, a[15]=false, b = inM, sel = instruction[12],
          out = aRegORmReg);

    /* A. L. U. computation */
    ALU(x = dReg,
        y = aRegORmReg,
        zx = instruction[11],
        nx = instruction[10],
        zy = instruction[9],
        ny = instruction[8],
        f =  instruction[7],
        no = instruction[6],
        out = aluValue,
        out = outM,
        zr = zr,
        ng = ng);

    /* jumps */
    Not(in = zr, out = notzero);
    Not(in = ng, out = positive);

    And(a=positive, b = notzero, out = strictpositive);
    Or(a=ng, b = zr, out = positiveorzero);

    DMux8Way(in = instruction[15], sel=instruction[0..2],
             a = false,
             b = jGT,
             c = jEQ,
             d = jGE,
             e = jLT,
             f = jNE, 
             g = jLE,
             h = jMP);

    And (a = jGT, b = strictpositive, out = jumpGT);
    And (a = jEQ, b = zr,             out = jumpEQ);
    And (a = jGE, b = positive,       out = jumpGE);
    And (a = jLT, b = ng,             out = jumpLT);
    And (a = jNE, b = notzero,        out = jumpNE);
    And (a = jLE, b = positiveorzero, out = jumpLE);

    Or8Way(in[0] = false,
           in[1] = jumpGT,
           in[2] = jumpEQ,
           in[3] = jumpGE,
           in[4] = jumpLT,
           in[5] = jumpNE,
           in[6] = jumpLE,
           in[7] = jMP,
           out = loadPC);
    
    Not(in = loadPC, out = incrementPC);
    
    /* Program Counter */
    PC(load = loadPC,
       inc = incrementPC,
       reset = reset,
       in[0..14] = aReg,
       in[15] = false,
       out[0..14] = pc);

    @instrument-reg-D dReg;
    @instrument-reg-A aReg;
    @instrument-reg-M writeM, outM, addressM;

}
